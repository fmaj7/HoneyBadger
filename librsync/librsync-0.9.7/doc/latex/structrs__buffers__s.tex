\hypertarget{structrs__buffers__s}{
\subsection{rs\_\-buffers\_\-s Struct Reference}
\label{structrs__buffers__s}\index{rs\_\-buffers\_\-s@{rs\_\-buffers\_\-s}}
}
Stream through which the calling application feeds data to and from the library.  


\subsubsection*{Data Fields}
\begin{CompactItemize}
\item 
char $\ast$ \hyperlink{structrs__buffers__s_6d5d12a1ced9a3a8891259e09c80ec20}{next\_\-in}
\begin{CompactList}\small\item\em Next input byte. \item\end{CompactList}\item 
size\_\-t \hyperlink{structrs__buffers__s_7bd5f1ea3c26587bf1106c1594712735}{avail\_\-in}
\begin{CompactList}\small\item\em Number of bytes available at next\_\-in. \item\end{CompactList}\item 
int \hyperlink{structrs__buffers__s_a6783da2d894c77178155759cd12d16f}{eof\_\-in}
\begin{CompactList}\small\item\em True if there is no more data after this. \item\end{CompactList}\item 
char $\ast$ \hyperlink{structrs__buffers__s_f3a6532c3e300a07783d61680cbdc11f}{next\_\-out}
\begin{CompactList}\small\item\em Next output byte should be put there. \item\end{CompactList}\item 
size\_\-t \hyperlink{structrs__buffers__s_e60f3db2f518d74aee13a02b7c9619a2}{avail\_\-out}
\begin{CompactList}\small\item\em Remaining free space at next\_\-out. \item\end{CompactList}\end{CompactItemize}


\subsubsection{Detailed Description}
Stream through which the calling application feeds data to and from the library. 

On each call to rs\_\-job\_\-iter, the caller can make available

\begin{itemize}
\item avail\_\-in bytes of input data at next\_\-in\item avail\_\-out bytes of output space at next\_\-out\item some of both\end{itemize}


Buffers must be allocated and passed in by the caller. This routine never allocates, reallocates or frees buffers.

Pay attention to the meaning of the returned pointer and length values. They do {\bf not} indicate the location and amount of returned data. Rather, if {\tt $\ast$out\_\-ptr} was originally set to {\tt out\_\-buf}, then the output data begins at {\tt out\_\-buf}, and has length {\tt $\ast$out\_\-ptr} - {\tt out\_\-buf}.

Note also that if {\tt $\ast$avail\_\-in} is nonzero on return, then not all of the input data has been consumed. The caller should either provide more output buffer space and call rs\_\-work() again passing the same {\tt next\_\-in} and {\tt avail\_\-in}, or put the remaining input data into some persistent buffer and call rs\_\-work() with it again when there is more output space.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em next\_\-in}]References a pointer which on entry should point to the start of the data to be encoded. Updated to point to the byte after the last one consumed.\item[{\em avail\_\-in}]References the length of available input. Updated to be the number of unused data bytes, which will be zero if all the input was consumed. May be zero if there is no new input, but the caller just wants to drain output.\item[{\em next\_\-out}]References a pointer which on entry points to the start of the output buffer. Updated to point to the byte after the last one filled.\item[{\em avail\_\-out}]References the size of available output buffer. Updated to the size of unused output buffer.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The \hyperlink{librsync_8h_7feb858ceba3b8f3cf048d49be108253}{rs\_\-result} that caused iteration to stop.\end{Desc}
\begin{Desc}
\item[See also:]\hyperlink{librsync_8h_bf9f543dbfe5c1e60c8ed1c93d087767}{rs\_\-buffers\_\-t} 

api\_\-buffers \end{Desc}


\subsubsection{Field Documentation}
\hypertarget{structrs__buffers__s_6d5d12a1ced9a3a8891259e09c80ec20}{
\index{rs\_\-buffers\_\-s@{rs\_\-buffers\_\-s}!next\_\-in@{next\_\-in}}
\index{next\_\-in@{next\_\-in}!rs_buffers_s@{rs\_\-buffers\_\-s}}
\paragraph[next\_\-in]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ {\bf rs\_\-buffers\_\-s::next\_\-in}}\hfill}
\label{structrs__buffers__s_6d5d12a1ced9a3a8891259e09c80ec20}


Next input byte. 

\hypertarget{structrs__buffers__s_7bd5f1ea3c26587bf1106c1594712735}{
\index{rs\_\-buffers\_\-s@{rs\_\-buffers\_\-s}!avail\_\-in@{avail\_\-in}}
\index{avail\_\-in@{avail\_\-in}!rs_buffers_s@{rs\_\-buffers\_\-s}}
\paragraph[avail\_\-in]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t {\bf rs\_\-buffers\_\-s::avail\_\-in}}\hfill}
\label{structrs__buffers__s_7bd5f1ea3c26587bf1106c1594712735}


Number of bytes available at next\_\-in. 

\hypertarget{structrs__buffers__s_a6783da2d894c77178155759cd12d16f}{
\index{rs\_\-buffers\_\-s@{rs\_\-buffers\_\-s}!eof\_\-in@{eof\_\-in}}
\index{eof\_\-in@{eof\_\-in}!rs_buffers_s@{rs\_\-buffers\_\-s}}
\paragraph[eof\_\-in]{\setlength{\rightskip}{0pt plus 5cm}int {\bf rs\_\-buffers\_\-s::eof\_\-in}}\hfill}
\label{structrs__buffers__s_a6783da2d894c77178155759cd12d16f}


True if there is no more data after this. 

\hypertarget{structrs__buffers__s_f3a6532c3e300a07783d61680cbdc11f}{
\index{rs\_\-buffers\_\-s@{rs\_\-buffers\_\-s}!next\_\-out@{next\_\-out}}
\index{next\_\-out@{next\_\-out}!rs_buffers_s@{rs\_\-buffers\_\-s}}
\paragraph[next\_\-out]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ {\bf rs\_\-buffers\_\-s::next\_\-out}}\hfill}
\label{structrs__buffers__s_f3a6532c3e300a07783d61680cbdc11f}


Next output byte should be put there. 

\hypertarget{structrs__buffers__s_e60f3db2f518d74aee13a02b7c9619a2}{
\index{rs\_\-buffers\_\-s@{rs\_\-buffers\_\-s}!avail\_\-out@{avail\_\-out}}
\index{avail\_\-out@{avail\_\-out}!rs_buffers_s@{rs\_\-buffers\_\-s}}
\paragraph[avail\_\-out]{\setlength{\rightskip}{0pt plus 5cm}size\_\-t {\bf rs\_\-buffers\_\-s::avail\_\-out}}\hfill}
\label{structrs__buffers__s_e60f3db2f518d74aee13a02b7c9619a2}


Remaining free space at next\_\-out. 



The documentation for this struct was generated from the following file:\begin{CompactItemize}
\item 
\hyperlink{librsync_8h}{librsync.h}\end{CompactItemize}
